1. 클래스의 다형성

다형성이란, 동일한 함수의 호출이 객체의 실제 타입에 따라 다른 동작을 하는 성질을 말한다.
C++에서는 virtual 함수와 포인터/참조를 통한 동적 바인딩으로 구현된다.

키워드 : virtual, override, dynamic binding, vtable

2. virtual의 의미 
가상의, 클래스의 멤버함수의 호출 대상(바인딩)이 런타임에 결정됨

3. 심화 개념
정적 다형성 : 오버로딩, 템플릿 - 컴파일 시점에 결정된다.
동적 다형성 : 오바라이딩 - 런타임 시점에 결정된다.
vtable(가상함수 테이블)을 통해 실제 객체 타입의 함수를 찾아 호출한다.

4. 예상 질문?
virtual 함수를 클래스의 생성자에 넣으면 안되는 이유?
: C++에서 객체는 기반 클래스 -> 파생 클래스 순으로 생성된다. 즉, 기반 클래스의 생성자에 virtual 함수를 호출할 경우, 파생 클래스의 vtable이 생성되지 않았기 때문에
실제 객체는 파생 클래스이더라도, 기반 클래스의 함수가 호출되는, 오버라이딩이 의도대로 동작하지 않는 상황이 발생한다.

virtual 함수를 클래스의 소멸자에 넣으면 안되는 이유?
: 생성자와 반대로 소멸자는 파생 클래스 -> 기반 클래스 순으로 호출된다. 따라서 기반 클래스의 소멸자에 virtual 함수를 호출할 경우, 이미 파생 클래스의 vtable이 해제된 상태이므로 정의되지 않은 동작과 같은 오류를 야기할 수 있다.

언제 동적 바인딩이 성립하나요?
: 기반 클래스 타입의 포인터/참조 형태로 멤버 함수를 호출할때. 정확한 타입을 알고 호출하는 경우에는 정적 바인딩이다.

기반 클래스에 virtual ~Base()가 필요한 이유?
: 가상 소멸자가 없으면 정적 바인딩으로 처리되며, 기반 클래스의 포인터에 파생 클래스의 주소값이 들어 잇을 경우, 파생 클래스의 소멸자가 호출되지 않아 메모리 누수의 위험이 발생한다. 가상 함수가 하나라도 있다면 소멸자도 가상으로 선언하는 게 사실상 관례